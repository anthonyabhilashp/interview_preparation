# General Interview Notes

Use this file to jot down important points, reminders, and general tips for your interview preparation.

## Example Sections

- Key Concepts
- Common Questions
- Personal Experiences
- Resources

---
Add your notes below:

An HLD (High-Level Design) shows how the system will work as a whole — focusing on architecture, components, data flow, and trade-offs, not on code or specific classes (that’s LLD).

It’s like a blueprint showing:
What major components exist
How they communicate
What data flows between them
What technologies could be used
How the system meets scalability, reliability, and performance goals

⚙️ Non-Functional Requirements (NFR)

These define how well the system should perform — i.e., qualities of service.
Example (Webhook Management System):
Scalability: Should handle 10k+ concurrent webhook deliveries.
Reliability: Delivery retries on failure (3 times, exponential backoff).
Latency: Deliver within 2 seconds of event generation.
Durability: No event should be lost even if the service restarts.
Security: Authenticate every delivery with HMAC signature.
Observability: Log and monitor webhook success/failure metrics.
Availability: 99.9% uptime.
👉 Think of NFR as "performance, reliability, and quality guarantees."


🧭 Step 3: How to Approach an HLD Interview Question

Let’s use a general 7-step HLD framework (you’ll reuse this for any system: Netflix, Instagram, Uber, Webhook Manager, etc.)


1. Understand the Problem

Ask clarifying questions before you design:
Who are the users?
What are the main use cases?
Any scale or constraint expectations?
What’s the SLA for delivery or latency?

👉 Example:
“Do we expect millions of webhook deliveries per day, or just a few thousand?”


2. Define the Functional & Non-Functional Requirements
As shown above — list both clearly.
This sets the stage and shows structured thinking.


3. Estimate Scale (Capacity Planning)

Roughly estimate:
Number of events per second
Payload size
Expected storage/log growth

This helps justify design decisions (e.g., message queues, DB choice).


4. Define Core Components (Architecture Diagram Level)

Break down into logical components:

API Gateway

Event Producer

Event Queue (Kafka / RabbitMQ)

Delivery Worker

Database (for event logs)

Retry Service

Dashboard / Monitoring

We can draw a diagram like:
[Client App] → [Event API] → [Queue] → [Delivery Workers] → [Target Webhook URLs]
                                          ↓
                                      [DB + Logs]

5. Explain Data Flow

Step-by-step:
1️⃣ Event is generated by client → sent to Event API
2️⃣ Event API stores it in DB + pushes it to Queue
3️⃣ Worker reads from Queue → sends webhook
4️⃣ If delivery fails, retries are scheduled
5️⃣ Dashboard reads logs for visibility


6. Choose Technologies

Explain your choices:
API layer → FastAPI / Node / Go
Queue → RabbitMQ / Kafka / Redis Streams
DB → PostgreSQL (logs) + Redis (temporary state)
Delivery → Async workers (Celery / BullMQ / custom Go service)
Monitoring → Prometheus + Grafana

7. Address NFRs and Trade-offs

Now show engineering judgment:

For scalability → horizontal scaling of workers

For durability → use persistent queues

For reliability → implement exponential backoff

For observability → structured logs + metrics

Trade-offs → delivery latency vs throughput


🧠 Bonus Tip: The Interview Mindset

When you speak, structure your answer like:

“Let’s start by defining the requirements.
Then I’ll design the architecture, explain the data flow, and finally, talk about scalability and trade-offs.”

That shows clarity and confidence.
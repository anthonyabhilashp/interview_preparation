# General Interview Notes

Use this file to jot down important points, reminders, and general tips for your interview preparation.

## Example Sections

- Key Concepts
- Common Questions
- Personal Experiences
- Resources

---
Add your notes below:

An HLD (High-Level Design) shows how the system will work as a whole â€” focusing on architecture, components, data flow, and trade-offs, not on code or specific classes (thatâ€™s LLD).

Itâ€™s like a blueprint showing:
What major components exist
How they communicate
What data flows between them
What technologies could be used
How the system meets scalability, reliability, and performance goals

âš™ï¸ Non-Functional Requirements (NFR)

These define how well the system should perform â€” i.e., qualities of service.
Example (Webhook Management System):
Scalability: Should handle 10k+ concurrent webhook deliveries.
Reliability: Delivery retries on failure (3 times, exponential backoff).
Latency: Deliver within 2 seconds of event generation.
Durability: No event should be lost even if the service restarts.
Security: Authenticate every delivery with HMAC signature.
Observability: Log and monitor webhook success/failure metrics.
Availability: 99.9% uptime.
ğŸ‘‰ Think of NFR as "performance, reliability, and quality guarantees."


ğŸ§­ Step 3: How to Approach an HLD Interview Question

Letâ€™s use a general 7-step HLD framework (youâ€™ll reuse this for any system: Netflix, Instagram, Uber, Webhook Manager, etc.)


1. Understand the Problem

Ask clarifying questions before you design:
Who are the users?
What are the main use cases?
Any scale or constraint expectations?
Whatâ€™s the SLA for delivery or latency?

ğŸ‘‰ Example:
â€œDo we expect millions of webhook deliveries per day, or just a few thousand?â€


2. Define the Functional & Non-Functional Requirements
As shown above â€” list both clearly.
This sets the stage and shows structured thinking.


3. Estimate Scale (Capacity Planning)

Roughly estimate:
Number of events per second
Payload size
Expected storage/log growth

This helps justify design decisions (e.g., message queues, DB choice).


4. Define Core Components (Architecture Diagram Level)

Break down into logical components:

API Gateway

Event Producer

Event Queue (Kafka / RabbitMQ)

Delivery Worker

Database (for event logs)

Retry Service

Dashboard / Monitoring

We can draw a diagram like:
[Client App] â†’ [Event API] â†’ [Queue] â†’ [Delivery Workers] â†’ [Target Webhook URLs]
                                          â†“
                                      [DB + Logs]

5. Explain Data Flow

Step-by-step:
1ï¸âƒ£ Event is generated by client â†’ sent to Event API
2ï¸âƒ£ Event API stores it in DB + pushes it to Queue
3ï¸âƒ£ Worker reads from Queue â†’ sends webhook
4ï¸âƒ£ If delivery fails, retries are scheduled
5ï¸âƒ£ Dashboard reads logs for visibility


6. Choose Technologies

Explain your choices:
API layer â†’ FastAPI / Node / Go
Queue â†’ RabbitMQ / Kafka / Redis Streams
DB â†’ PostgreSQL (logs) + Redis (temporary state)
Delivery â†’ Async workers (Celery / BullMQ / custom Go service)
Monitoring â†’ Prometheus + Grafana

7. Address NFRs and Trade-offs

Now show engineering judgment:

For scalability â†’ horizontal scaling of workers

For durability â†’ use persistent queues

For reliability â†’ implement exponential backoff

For observability â†’ structured logs + metrics

Trade-offs â†’ delivery latency vs throughput


ğŸ§  Bonus Tip: The Interview Mindset

When you speak, structure your answer like:

â€œLetâ€™s start by defining the requirements.
Then Iâ€™ll design the architecture, explain the data flow, and finally, talk about scalability and trade-offs.â€

That shows clarity and confidence.